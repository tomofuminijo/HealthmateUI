<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    
    <!-- htmx -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', path='/css/style.css') }}">
</head>
<body class="bg-gray-50 h-screen overflow-hidden">
    <!-- Navigation -->
    <nav class="bg-white shadow-sm border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <a href="/" class="text-xl font-semibold text-gray-900">
                        ğŸ¥ Healthmate
                    </a>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="logout-btn" class="text-gray-600 hover:text-gray-900">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Chat Container - Full height minus nav -->
    <div class="chat-container flex flex-col mx-auto w-full max-w-4xl bg-white sm:shadow-lg sm:my-4 sm:rounded-lg overflow-hidden" style="height: calc(100vh - 64px);">
        <style>
            @media (min-width: 640px) {
                .chat-container {
                    height: calc(100vh - 96px) !important;
                }
            }
        </style>
    <!-- Chat Header -->
    <div class="bg-white shadow-sm border-b px-4 sm:px-6 py-4">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-3">
                <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                    <span class="text-white text-sm font-semibold">ğŸ¤–</span>
                </div>
                <div>
                    <h1 class="text-lg font-semibold text-gray-900">å¥åº·ã‚³ãƒ¼ãƒ</h1>
                    <!-- Connection status - only shown when there's an issue -->
                    <p class="text-sm text-red-500 hidden" id="connection-error">ã‚³ãƒ¼ãƒä¼‘æ†©ä¸­ã§ã™...</p>
                </div>
            </div>
            <!-- Chat controls and status -->
            <div class="flex items-center space-x-2">
                <!-- New Chat Button -->
                <button 
                    id="new-chat-btn"
                    class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200"
                    title="æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹">
                    <svg class="w-4 h-4 mr-1.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                    </svg>
                    æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆ
                </button>
                
                <!-- Status indicator - only shown when there's an issue -->
                <span id="status-indicator" class="hidden inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                    ä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“
                </span>
            </div>
        </div>
    </div>

    <!-- Chat Messages Container -->
    <div class="flex-1 overflow-hidden">
        <div 
            id="chat-messages" 
            class="h-full overflow-y-auto px-4 sm:px-6 py-4 space-y-4"
            hx-swap="innerHTML">
            <!-- Loading indicator -->
            <div class="flex items-center justify-center py-8">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                <span class="ml-2 text-gray-500">ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‚’èª­ã¿è¾¼ã¿ä¸­...</span>
            </div>
        </div>
    </div>

    <!-- Chat Input -->
    <div class="bg-white border-t px-4 sm:px-6 py-4">
        <form 
            id="chat-form" 
            class="flex space-x-3">
            <div class="flex-1 relative">
                <textarea 
                    id="message-input"
                    name="message"
                    rows="1"
                    class="block w-full resize-none border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm transition-all duration-200"
                    style="caret-color: auto; padding: 8px 12px;"
                    placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„... (Enter: é€ä¿¡, Shift+Enter: æ”¹è¡Œ, Ctrl+Enter: å¼·åˆ¶é€ä¿¡, Esc: ã‚¯ãƒªã‚¢)"
                    maxlength="1000"
                    required
                    autocomplete="off"
                    spellcheck="false"></textarea>
                
                <!-- Input hint overlay -->
                <div class="absolute bottom-2 right-2 text-xs text-gray-400 pointer-events-none">
                    <span class="hidden sm:inline">Ctrl+Enter: é€ä¿¡</span>
                </div>
            </div>
            <button 
                type="submit"
                id="send-button"
                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
                title="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ (Enter ã¾ãŸã¯ Ctrl+Enter)">
                <span id="send-text">é€ä¿¡</span>
                <span id="send-spinner" class="htmx-indicator ml-2">
                    <svg class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </span>
                <!-- Send icon -->
                <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                </svg>
            </button>
        </form>
        
        <!-- Character Counter and Input Hints -->
        <div class="mt-2 flex justify-between items-center">
            <div class="text-xs text-gray-400">
                <span class="hidden sm:inline">ğŸ’¡ ãƒ’ãƒ³ãƒˆ: Enterã§é€ä¿¡ã€Shift+Enterã§æ”¹è¡Œã€Ctrl+Enterã§å¼·åˆ¶é€ä¿¡ã€Escã§ã‚¯ãƒªã‚¢</span>
                <span class="sm:hidden">ğŸ’¡ Enterã§é€ä¿¡</span>
            </div>
            <div class="flex items-center space-x-2">
                <span id="char-counter" class="text-xs text-gray-500">0/1000</span>
                <button 
                    type="button" 
                    id="clear-input-btn"
                    class="text-xs text-gray-400 hover:text-gray-600 transition-colors duration-200"
                    title="å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢ (Esc)">
                    ã‚¯ãƒªã‚¢
                </button>
            </div>
        </div>
        

    </div>

    <!-- Custom JavaScript -->
    <script src="{{ url_for('static', path='/js/app.js') }}"></script>
<script>
// Chat functionality with htmx integration
class ChatInterface {
    constructor() {
        this.messageInput = document.getElementById('message-input');
        this.chatForm = document.getElementById('chat-form');
        this.chatMessages = document.getElementById('chat-messages');
        this.sendButton = document.getElementById('send-button');
        this.sendText = document.getElementById('send-text');
        this.sendSpinner = document.getElementById('send-spinner');
        this.charCounter = document.getElementById('char-counter');
        this.connectionError = document.getElementById('connection-error');
        this.statusIndicator = document.getElementById('status-indicator');
        this.streamingResponse = null;
        this.streamingText = null;
        this.typingIndicator = null;
        this.thinkingIndicator = null;
        
        this.eventSource = null;
        this.isStreaming = false;
        this.isComposing = false; // IME composition state
        this.isNewSessionJustCreated = false; // Flag for new session display
        
        // Initialize session
        this.sessionId = this.getOrCreateSessionId();
        
        this.init();
    }
    
    init() {
        // Check authentication status first
        this.checkAuthenticationStatus();
        
        // Auto-resize textarea
        this.messageInput.addEventListener('input', () => this.handleInput());
        
        // Character counter and send button state
        this.messageInput.addEventListener('input', () => {
            this.updateCharCounter();
            this.updateSendButtonState();
        });
        
        // Enter key handling
        this.messageInput.addEventListener('keydown', (e) => this.handleKeyDown(e));
        
        // IME composition handling for Japanese input
        this.messageInput.addEventListener('compositionstart', () => {
            this.isComposing = true;
        });
        this.messageInput.addEventListener('compositionend', () => {
            this.isComposing = false;
        });
        
        // Focus management
        this.messageInput.addEventListener('focus', () => this.onInputFocus());
        this.messageInput.addEventListener('blur', () => this.onInputBlur());
        
        // Clear button
        document.getElementById('clear-input-btn').addEventListener('click', () => {
            this.clearInput();
        });
        
        // New chat button
        document.getElementById('new-chat-btn').addEventListener('click', () => {
            this.startNewChatSession();
        });
        
        // Chat form submission
        this.chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleFormSubmit();
        });
        
        // Initialize streaming connection
        this.initializeStreaming();
        
        // Set initial focus
        setTimeout(() => {
            this.messageInput.focus();
        }, 100);
        
        // Initial send button state
        this.updateSendButtonState();
        
        // Update history loading URL with current session ID
        this.updateHistoryLoadingUrl();
        
        // Load initial chat history (delay to ensure htmx is ready)
        setTimeout(() => {
            this.loadInitialHistory();
        }, 500);
    }
    
    checkAuthenticationStatus() {
        // Check if we have authentication cookies
        const hasAuthCookie = document.cookie.includes('healthmate_session');
        
        if (!hasAuthCookie) {
            console.warn('No authentication cookie found - user may not be logged in');
            // Don't redirect immediately, let the API call handle it
        }
    }
    
    updateSendButtonState() {
        const hasText = this.messageInput.value.trim().length > 0;
        const isNotLoading = !this.sendButton.disabled;
        
        if (hasText && isNotLoading) {
            this.sendButton.classList.remove('opacity-50');
            this.sendButton.classList.add('hover:bg-blue-700');
        } else {
            this.sendButton.classList.add('opacity-50');
            this.sendButton.classList.remove('hover:bg-blue-700');
        }
    }
    
    onInputFocus() {
        // Visual feedback when input is focused
        this.messageInput.parentElement.classList.add('ring-2', 'ring-blue-500');
    }
    
    onInputBlur() {
        // Remove visual feedback when input loses focus
        this.messageInput.parentElement.classList.remove('ring-2', 'ring-blue-500');
    }
    
    setupHtmxEvents() {
        // Keep htmx events for chat history loading only
        // Chat form submission is now handled by custom streaming
    }
    
    initializeStreaming() {
        // Connect to streaming endpoint
        if (typeof EventSource !== 'undefined') {
            this.eventSource = new EventSource('/api/streaming/connect');
            
            this.eventSource.onopen = () => {
                console.log('Streaming connection opened');
                this.hideConnectionError();
            };
            
            this.eventSource.onmessage = (event) => {
                this.handleStreamingMessage(event.data);
            };
            
            this.eventSource.onerror = (error) => {
                console.error('Streaming error:', error);
                this.showConnectionError();
            };
        }
    }
    
    handleStreamingMessage(data) {
        try {
            const message = JSON.parse(data);
            
            if (message.type === 'chunk') {
                this.handleStreamingChunk(message.data);
            } else if (message.type === 'complete') {
                this.handleStreamingComplete(message.data);
            } else if (message.type === 'error') {
                this.handleStreamingError(message.data);
            }
        } catch (error) {
            console.error('Error parsing streaming message:', error);
        }
    }
    
    handleStreamingChunk(data) {
        if (!this.isStreaming) {
            this.startStreaming();
        }
        
        // Append text chunk
        this.streamingText.textContent += data.text;
        this.scrollToBottom();
    }
    
    handleStreamingComplete(data) {
        if (this.isStreaming) {
            this.completeStreaming();
        }
    }
    
    handleStreamingError(data) {
        if (this.isStreaming) {
            this.completeStreaming();
        }
        this.addErrorMessage(data.error || 'ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
    }
    
    startStreaming() {
        console.log('startStreaming called');
        this.isStreaming = true;
        
        // Create streaming response element in the chat messages area
        this.streamingResponse = document.createElement('div');
        this.streamingResponse.className = 'flex items-start space-x-3';
        this.streamingResponse.innerHTML = `
            <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center flex-shrink-0">
                <span class="text-white text-sm">ğŸ¤–</span>
            </div>
            <div class="flex-1">
                <div class="bg-gray-100 rounded-lg px-4 py-2">
                    <div id="thinking-indicator" class="flex items-center space-x-2 text-gray-600">
                        <span class="text-sm">ğŸ¤”</span>
                        <span class="text-sm">è€ƒãˆä¸­</span>
                        <div class="flex space-x-1">
                            <div class="w-1 h-1 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0ms;"></div>
                            <div class="w-1 h-1 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 150ms;"></div>
                            <div class="w-1 h-1 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 300ms;"></div>
                        </div>
                    </div>
                    <p id="streaming-text" class="text-gray-900 whitespace-pre-wrap hidden"></p>
                    <div id="typing-indicator" class="inline-block w-2 h-4 bg-blue-500 animate-pulse hidden"></div>
                </div>
            </div>
        `;
        
        // Add to chat messages area
        this.chatMessages.appendChild(this.streamingResponse);
        
        // Get references to the created elements
        this.streamingText = document.getElementById('streaming-text');
        this.typingIndicator = document.getElementById('typing-indicator');
        this.thinkingIndicator = document.getElementById('thinking-indicator');
        
        this.scrollToBottom();
        
        console.log('Streaming response created in chat area with thinking indicator');
        console.log('Streaming text element:', this.streamingText);
    }
    
    completeStreaming() {
        this.isStreaming = false;
        
        if (this.typingIndicator) {
            this.typingIndicator.style.display = 'none';
        }
        
        // Convert streaming response to permanent message
        const finalText = this.streamingText ? this.streamingText.textContent : '';
        if (finalText && this.streamingResponse) {
            // Replace streaming response with permanent message
            const permanentMessage = this.createMessageElement(finalText, 'assistant');
            this.chatMessages.replaceChild(permanentMessage, this.streamingResponse);
        }
        
        // Clean up references
        this.streamingResponse = null;
        this.streamingText = null;
        this.typingIndicator = null;
        this.thinkingIndicator = null;
        
        // Connection is working normally - no status display needed
        
        // Re-enable input
        this.setInputDisabled(false);
        
        this.scrollToBottom();
    }
    
    async startStreamingResponse(message) {
        try {
            console.log('Starting streaming response for message:', message);
            // Start streaming display
            this.startStreaming();
            console.log('Streaming display started');
            
            // Create streaming request with session ID
            console.log('Making fetch request to /api/streaming/chat');
            const response = await fetch('/api/streaming/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'text/event-stream'
                },
                credentials: 'include', // Include cookies for authentication
                body: JSON.stringify({
                    message: message,
                    timezone: 'Asia/Tokyo',
                    language: 'ja',
                    session_attributes: {
                        session_id: this.sessionId
                    }
                })
            });
            
            console.log('Fetch response received:', response.status, response.statusText);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            // Process Server-Sent Events
            console.log('Starting to read response stream');
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            while (true) {
                const { done, value } = await reader.read();
                
                if (done) {
                    console.log('Stream reading completed');
                    break;
                }
                
                // Add to buffer
                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                console.log('Received chunk:', chunk);
                
                // Process complete lines
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // Keep incomplete line in buffer
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const eventData = JSON.parse(line.slice(6));
                            console.log('Parsed event data:', eventData);
                            this.handleStreamingEvent(eventData);
                        } catch (e) {
                            console.error('Error parsing SSE data:', e, 'Line:', line);
                        }
                    }
                }
            }
            
        } catch (error) {
            console.error('Streaming error:', error);
            this.addErrorMessage(`ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            this.completeStreaming();
        }
    }
    
    handleStreamingEvent(eventData) {
        console.log('Streaming event:', eventData);
        
        switch (eventData.event_type) {
            case 'connected':
                console.log('Streaming connected');
                break;
                
            case 'user_message':
                console.log('User message confirmed');
                break;
                
            case 'ai_thinking':
                // AI is thinking - no status display needed
                break;
                
            case 'ai_chunk':
                if (eventData.text) {
                    console.log('Adding text chunk:', eventData.text);
                    
                    // Ensure streaming is started
                    if (!this.isStreaming) {
                        console.log('Starting streaming because isStreaming is false');
                        this.startStreaming();
                    }
                    
                    // Hide thinking indicator and show streaming text on first chunk
                    if (this.thinkingIndicator && !this.thinkingIndicator.classList.contains('hidden')) {
                        this.thinkingIndicator.classList.add('hidden');
                        this.streamingText.classList.remove('hidden');
                        this.typingIndicator.classList.remove('hidden');
                        console.log('Switched from thinking to streaming display');
                    }
                    
                    this.streamingText.textContent += eventData.text;
                    console.log('Current streaming text:', this.streamingText.textContent);
                    this.scrollToBottom();
                }
                break;
                
            case 'ai_message_complete':
                console.log('AI message complete');
                break;
                
            case 'complete':
                this.completeStreaming();
                break;
                
            case 'error':
                console.error('Streaming error:', eventData.error);
                this.addErrorMessage(`ã‚¨ãƒ©ãƒ¼: ${eventData.error}`);
                this.completeStreaming();
                break;
                
            case 'disconnected':
                console.log('Streaming disconnected');
                break;
                
            default:
                console.log('Unknown streaming event:', eventData);
        }
    }
    
    handleInput() {
        // Use requestAnimationFrame to ensure smooth cursor visibility
        requestAnimationFrame(() => {
            this.adjustTextareaHeight();
        });
    }
    
    handleKeyDown(e) {
        // Check if IME is composing (Japanese input conversion)
        if (this.isComposing || e.isComposing || e.keyCode === 229) {
            // During IME composition, don't handle Enter key
            return;
        }
        
        // Shift + Enter: Allow new line (don't prevent default)
        if (e.key === 'Enter' && e.shiftKey && !e.ctrlKey && !e.metaKey) {
            // Let the default behavior happen (insert new line)
            // Don't manually adjust height here - let the input event handle it
            return;
        }
        
        // Ctrl/Cmd + Enter: Force send message even with Shift
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            this.submitMessage();
            return;
        }
        
        // Enter key: Send message (only if no modifier keys)
        if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            this.submitMessage();
            return;
        }
        
        // Escape key: Clear input and focus
        if (e.key === 'Escape') {
            e.preventDefault();
            this.clearInput();
            this.messageInput.focus();
            return;
        }
        
        // Ctrl/Cmd + K: Clear chat
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            this.clearChat();
            return;
        }
    }
    
    submitMessage() {
        if (!this.sendButton.disabled && this.messageInput.value.trim()) {
            this.handleFormSubmit();
        }
    }
    
    clearInputAndMaintainFocus() {
        // Clear the input field
        this.messageInput.value = '';
        
        // Update character counter
        this.updateCharCounter();
        
        // Reset textarea height
        this.adjustTextareaHeight();
        
        // Maintain focus for next message (è¦ä»¶ 2.4)
        // Use setTimeout to ensure the input is ready for focus
        setTimeout(() => {
            if (!this.messageInput.disabled) {
                this.messageInput.focus();
                // Ensure cursor is visible
                this.messageInput.setSelectionRange(0, 0);
            }
        }, 50);
        
        // Update send button state
        this.updateSendButtonState();
    }
    
    setInputDisabled(disabled) {
        this.messageInput.disabled = disabled;
        this.sendButton.disabled = disabled;
        
        if (disabled) {
            this.messageInput.classList.add('opacity-50', 'cursor-not-allowed');
        } else {
            this.messageInput.classList.remove('opacity-50', 'cursor-not-allowed');
            // Restore focus after enabling
            setTimeout(() => {
                this.messageInput.focus();
            }, 100);
        }
    }
    
    adjustTextareaHeight() {
        // Save current state
        const cursorPosition = this.messageInput.selectionStart;
        const cursorEnd = this.messageInput.selectionEnd;
        const hasFocus = document.activeElement === this.messageInput;
        const currentHeight = this.messageInput.style.height;
        
        // Calculate new height without changing the current height first
        const tempElement = this.messageInput.cloneNode(true);
        tempElement.style.position = 'absolute';
        tempElement.style.visibility = 'hidden';
        tempElement.style.height = 'auto';
        tempElement.style.width = this.messageInput.offsetWidth + 'px';
        document.body.appendChild(tempElement);
        
        const newHeight = Math.min(tempElement.scrollHeight, 120);
        document.body.removeChild(tempElement);
        
        // Only update height if it actually changed
        if (currentHeight !== newHeight + 'px') {
            this.messageInput.style.height = newHeight + 'px';
        }
        
        // Force cursor visibility with a micro-delay
        if (hasFocus) {
            requestAnimationFrame(() => {
                this.messageInput.focus();
                this.messageInput.setSelectionRange(cursorPosition, cursorEnd);
                // Force a repaint to ensure cursor visibility
                this.messageInput.style.caretColor = 'transparent';
                requestAnimationFrame(() => {
                    this.messageInput.style.caretColor = '';
                });
            });
        }
    }
    
    updateCharCounter() {
        const length = this.messageInput.value.length;
        this.charCounter.textContent = `${length}/1000`;
        
        if (length > 900) {
            this.charCounter.classList.add('text-red-500');
        } else {
            this.charCounter.classList.remove('text-red-500');
        }
    }
    
    addUserMessage(content) {
        const messageDiv = this.createMessageElement(content, 'user');
        this.chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    addAssistantMessage(content) {
        const messageDiv = this.createMessageElement(content, 'assistant');
        this.chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    addErrorMessage(content) {
        const messageDiv = this.createMessageElement(content, 'error');
        this.chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    addUserMessage(content) {
        const messageDiv = this.createMessageElement(content, 'user');
        this.chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    startStreaming() {
        console.log('startStreaming called');
        this.isStreaming = true;
        
        // Create streaming response element in the chat messages area
        this.streamingResponse = document.createElement('div');
        this.streamingResponse.className = 'flex items-start space-x-3';
        this.streamingResponse.innerHTML = `
            <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center flex-shrink-0">
                <span class="text-white text-sm">ğŸ¤–</span>
            </div>
            <div class="flex-1">
                <div class="bg-gray-100 rounded-lg px-4 py-2">
                    <div id="thinking-indicator" class="flex items-center space-x-2 text-gray-600">
                        <span class="text-sm">ğŸ¤”</span>
                        <span class="text-sm">è€ƒãˆä¸­</span>
                        <div class="flex space-x-1">
                            <div class="w-1 h-1 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0ms;"></div>
                            <div class="w-1 h-1 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 150ms;"></div>
                            <div class="w-1 h-1 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 300ms;"></div>
                        </div>
                    </div>
                    <p id="streaming-text" class="text-gray-900 whitespace-pre-wrap hidden"></p>
                    <div id="typing-indicator" class="inline-block w-2 h-4 bg-blue-500 animate-pulse hidden"></div>
                </div>
            </div>
        `;
        
        // Add to chat messages area
        this.chatMessages.appendChild(this.streamingResponse);
        
        // Get references to the created elements
        this.streamingText = document.getElementById('streaming-text');
        this.typingIndicator = document.getElementById('typing-indicator');
        this.thinkingIndicator = document.getElementById('thinking-indicator');
        
        this.scrollToBottom();
        
        console.log('Streaming response created in chat area with thinking indicator');
        console.log('Streaming text element:', this.streamingText);
    }
    
    completeStreaming() {
        this.isStreaming = false;
        
        if (this.typingIndicator) {
            this.typingIndicator.style.display = 'none';
        }
        
        // Convert streaming response to permanent message
        const finalText = this.streamingText ? this.streamingText.textContent : '';
        if (finalText && this.streamingResponse) {
            // Replace streaming response with permanent message
            const permanentMessage = this.createMessageElement(finalText, 'assistant');
            this.chatMessages.replaceChild(permanentMessage, this.streamingResponse);
        }
        
        // Clean up references
        this.streamingResponse = null;
        this.streamingText = null;
        this.typingIndicator = null;
        this.thinkingIndicator = null;
        
        // Connection is working normally - no status display needed
        
        // Re-enable input
        this.setInputDisabled(false);
        
        this.scrollToBottom();
    }
    
    handleStreamingEvent(eventData) {
        console.log('Streaming event:', eventData);
        
        switch (eventData.event_type) {
            case 'connected':
                console.log('Streaming connected');
                break;
                
            case 'user_message':
                console.log('User message confirmed');
                break;
                
            case 'ai_thinking':
                // AI is thinking - no status display needed
                break;
                
            case 'ai_chunk':
                if (eventData.text) {
                    console.log('Adding text chunk:', eventData.text);
                    
                    // Ensure streaming is started
                    if (!this.isStreaming) {
                        console.log('Starting streaming because isStreaming is false');
                        this.startStreaming();
                    }
                    
                    // Hide thinking indicator and show streaming text on first chunk
                    if (this.thinkingIndicator && !this.thinkingIndicator.classList.contains('hidden')) {
                        this.thinkingIndicator.classList.add('hidden');
                        this.streamingText.classList.remove('hidden');
                        this.typingIndicator.classList.remove('hidden');
                        console.log('Switched from thinking to streaming display');
                    }
                    
                    this.streamingText.textContent += eventData.text;
                    console.log('Current streaming text:', this.streamingText.textContent);
                    this.scrollToBottom();
                }
                break;
                
            case 'ai_message_complete':
                console.log('AI message complete');
                break;
                
            case 'complete':
                this.completeStreaming();
                break;
                
            case 'error':
                console.error('Streaming error:', eventData.error);
                this.addErrorMessage(`ã‚¨ãƒ©ãƒ¼: ${eventData.error}`);
                this.completeStreaming();
                break;
                
            case 'disconnected':
                console.log('Streaming disconnected');
                break;
                
            default:
                console.log('Unknown streaming event:', eventData);
        }
    }
    
    handleStreamingEvent(eventData) {
        console.log('Streaming event:', eventData);
        
        switch (eventData.event_type) {
            case 'connected':
                console.log('Streaming connected');
                break;
                
            case 'user_message':
                console.log('User message confirmed');
                break;
                
            case 'ai_thinking':
                // AI is thinking - no status display needed
                break;
                
            case 'ai_chunk':
                if (eventData.text) {
                    console.log('Adding text chunk:', eventData.text);
                    
                    // Ensure streaming is started
                    if (!this.isStreaming) {
                        console.log('Starting streaming because isStreaming is false');
                        this.startStreaming();
                    }
                    
                    // Hide thinking indicator and show streaming text on first chunk
                    if (this.thinkingIndicator && !this.thinkingIndicator.classList.contains('hidden')) {
                        this.thinkingIndicator.classList.add('hidden');
                        this.streamingText.classList.remove('hidden');
                        this.typingIndicator.classList.remove('hidden');
                        console.log('Switched from thinking to streaming display');
                    }
                    
                    this.streamingText.textContent += eventData.text;
                    console.log('Current streaming text:', this.streamingText.textContent);
                    this.scrollToBottom();
                }
                break;
                
            case 'ai_message_complete':
                console.log('AI message complete');
                break;
                
            case 'complete':
                this.completeStreaming();
                break;
                
            case 'error':
                console.error('Streaming error:', eventData.error);
                this.addErrorMessage(`ã‚¨ãƒ©ãƒ¼: ${eventData.error}`);
                this.completeStreaming();
                break;
                
            case 'disconnected':
                console.log('Streaming disconnected');
                break;
                
            default:
                console.log('Unknown streaming event:', eventData);
        }
    }
    
    createMessageElement(content, sender) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'flex items-start space-x-3';
        
        const isUser = sender === 'user';
        const isError = sender === 'error';
        const timestamp = new Date().toLocaleTimeString('ja-JP', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
        
        let bgColor, icon;
        if (isUser) {
            bgColor = 'bg-blue-100';
            icon = 'ğŸ‘¤';
        } else if (isError) {
            bgColor = 'bg-red-100';
            icon = 'âš ï¸';
        } else {
            bgColor = 'bg-gray-100';
            icon = 'ğŸ¤–';
        }
        
        // Escape HTML and convert newlines to <br> tags (consistent with chat_history.html)
        const escapedContent = HealthmateUI.utils.escapeHtml(content).replace(/\n/g, '<br>');
        
        messageDiv.innerHTML = `
            <div class="w-8 h-8 ${isUser ? 'bg-gray-400' : isError ? 'bg-red-500' : 'bg-blue-500'} rounded-full flex items-center justify-center flex-shrink-0">
                <span class="text-white text-sm">${icon}</span>
            </div>
            <div class="flex-1">
                <div class="${bgColor} rounded-lg px-4 py-2">
                    <p class="text-gray-900 leading-relaxed">${escapedContent}</p>
                </div>
                <p class="text-xs text-gray-500 mt-1">${timestamp}</p>
            </div>
        `;
        
        return messageDiv;
    }
    
    clearInput() {
        this.messageInput.value = '';
        this.updateCharCounter();
        this.adjustTextareaHeight();
        
        // Ensure input is enabled and focused
        this.setInputDisabled(false);
        
        // Focus the input field for next message (è¦ä»¶ 2.4)
        setTimeout(() => {
            this.messageInput.focus();
            // Ensure cursor is positioned at the beginning
            this.messageInput.setSelectionRange(0, 0);
        }, 50);
    }
    
    setLoading(loading) {
        this.setInputDisabled(loading);
        
        if (loading) {
            this.sendText.textContent = 'é€ä¿¡ä¸­...';
        } else {
            this.sendText.textContent = 'é€ä¿¡';
        }
    }
    
    scrollToBottom() {
        this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
    }
    
    showConnectionError() {
        if (this.connectionError) {
            this.connectionError.classList.remove('hidden');
        }
        if (this.statusIndicator) {
            this.statusIndicator.classList.remove('hidden');
        }
    }
    
    hideConnectionError() {
        if (this.connectionError) {
            this.connectionError.classList.add('hidden');
        }
        if (this.statusIndicator) {
            this.statusIndicator.classList.add('hidden');
        }
    }

    getOrCreateSessionId() {
        // Check if we already have a session ID in sessionStorage
        let sessionId = sessionStorage.getItem('healthmate_chat_session_id');
        
        if (!sessionId) {
            // Generate a new session ID (must be at least 33 characters)
            const timestamp = Date.now().toString();
            const randomPart1 = Math.random().toString(36).substr(2, 15);
            const randomPart2 = Math.random().toString(36).substr(2, 15);
            sessionId = `healthmate-chat-${timestamp}-${randomPart1}-${randomPart2}`;
            
            // Ensure it's at least 33 characters
            while (sessionId.length < 33) {
                sessionId += Math.random().toString(36).substr(2, 1);
            }
            
            sessionStorage.setItem('healthmate_chat_session_id', sessionId);
        }
        
        return sessionId;
    }
    
    resetChatSession() {
        // Clear the session ID to start a new conversation
        sessionStorage.removeItem('healthmate_chat_session_id');
        
        // Don't set persistent flag - let the session naturally be empty

    }
    
    startNewChatSession() {
        // Confirm with user before starting new session
        if (confirm('æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ\n\nç¾åœ¨ã®ä¼šè©±ã¯çµ‚äº†ã—ã€æ–°ã—ã„ä¼šè©±ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒå§‹ã¾ã‚Šã¾ã™ã€‚\nï¼ˆæ³¨æ„ï¼šã‚ãªãŸã®é•·æœŸè¨˜æ†¶ã¯ä¿æŒã•ã‚Œã¾ã™ãŒã€ç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æ–‡è„ˆã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ï¼‰')) {
            // Clear the chat messages display
            this.chatMessages.innerHTML = '<div class="flex items-center justify-center py-8"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div><span class="ml-2 text-gray-500">æ–°ã—ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ä¸­...</span></div>';
            
            // Reset the session to start fresh
            this.resetChatSession();
            this.sessionId = this.getOrCreateSessionId();
            
            // Update the htmx history loading URL to use the new session ID
            this.updateHistoryLoadingUrl();
            
            // Clear the chat messages and show welcome message immediately
            this.chatMessages.innerHTML = '';
            this.addAssistantMessage('æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼\n\nç§ã¯ã‚ãªãŸã®å¥åº·ã‚³ãƒ¼ãƒAIã§ã™ã€‚éå»ã®ä¼šè©±å†…å®¹ã‚’è¦šãˆã¦ã„ã‚‹ã®ã§ã€ç¶™ç¶šçš„ãªã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã§ãã¾ã™ã€‚ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ');
            
            // Set a flag to indicate this is a truly new session (only for immediate display)
            // This flag should NOT persist across page refreshes
            this.isNewSessionJustCreated = true;
            
    
        }
    }
    
    updateHistoryLoadingUrl() {
        // Update the htmx history loading URL to include current session ID
        const historyUrl = `/api/chat/history?session_id=${encodeURIComponent(this.sessionId)}`;
        this.chatMessages.setAttribute('hx-get', historyUrl);
        console.log('Updated history loading URL:', historyUrl);
        console.log('Current session ID:', this.sessionId);
    }
    
    loadChatHistory() {
        // Load chat history for current session
        if (typeof htmx !== 'undefined') {
            htmx.trigger(this.chatMessages, 'loadHistory');
        }
    }
    
    loadInitialHistory() {
        // Skip loading if this is a new session that was just created in this page load
        if (this.isNewSessionJustCreated) {
            return;
        }
        
        // Load initial chat history using fetch with session ID
        const historyUrl = `/api/chat/history?session_id=${encodeURIComponent(this.sessionId)}`;
        
        // Show loading indicator
        this.chatMessages.innerHTML = '<div class="flex items-center justify-center py-8"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div><span class="ml-2 text-gray-500">ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‚’èª­ã¿è¾¼ã¿ä¸­...</span></div>';
        
        // Use fetch to ensure cookies are included
        fetch(historyUrl, {
            method: 'GET',
            credentials: 'include',  // Include cookies
            headers: {
                'HX-Request': 'true',
                'Accept': 'text/html'
            }
        }).then(async (response) => {
            if (response.ok) {
                const html = await response.text();
                this.chatMessages.innerHTML = html;
                this.scrollToBottom();
            } else if (response.status === 401) {
                console.error('Authentication failed - user not logged in or session expired');
                
                // Show authentication error message instead of immediate redirect
                this.chatMessages.innerHTML = `
                    <div class="flex items-center justify-center py-8">
                        <div class="text-center">
                            <div class="text-red-500 mb-4">
                                <svg class="w-12 h-12 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 15.5c-.77.833.192 2.5 1.732 2.5z"></path>
                                </svg>
                                <h3 class="text-lg font-medium">èªè¨¼ãŒå¿…è¦ã§ã™</h3>
                            </div>
                            <p class="text-gray-600 mb-4">ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™ã€‚</p>
                            <button onclick="window.location.href='/login'" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg">
                                ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã¸
                            </button>
                        </div>
                    </div>
                `;
            } else {
                const errorText = await response.text();
                console.error('HTTP error response:', errorText);
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        }).catch((error) => {
            console.error('Failed to load initial chat history:', error);
            
            // Show welcome message if no history or error
            this.showWelcomeMessage();
        });
    }
    
    showWelcomeMessage() {
        // Clear messages and show welcome message directly
        console.log('Showing welcome message for session:', this.sessionId);
        
        this.chatMessages.innerHTML = '';
        
        // Try to load empty history from server first, fallback to client-side message
        const emptyHistoryUrl = `/api/chat/history?session_id=${encodeURIComponent(this.sessionId)}`;
        console.log('Attempting to load empty history from server...');
        
        fetch(emptyHistoryUrl, {
            method: 'GET',
            credentials: 'include',  // Include cookies
            headers: {
                'HX-Request': 'true',
                'Accept': 'text/html'
            }
        }).then(async (response) => {
            if (response.ok) {
                const html = await response.text();
                this.chatMessages.innerHTML = html;
                console.log('Empty history loaded from server');
                this.scrollToBottom();
            } else if (response.status === 401) {
                console.log('Authentication error, redirecting to login');
                window.location.href = '/login';
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        }).catch((error) => {
            console.error('Failed to load empty history from server:', error);
            // Fallback to client-side welcome message
            this.showClientWelcomeMessage();
        });
    }
    
    showClientWelcomeMessage() {
        // Show welcome message directly in the client
        console.log('Showing client-side welcome message');
        
        this.chatMessages.innerHTML = `
            <div class="flex items-start space-x-3 mb-4 animate-fade-in">
                <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center flex-shrink-0 shadow-sm">
                    <span class="text-white text-sm">ğŸ¤–</span>
                </div>
                <div class="flex-1 max-w-3xl">
                    <div class="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg px-4 py-3 shadow-sm">
                        <div class="text-gray-900 leading-relaxed">
                            <p class="font-medium text-blue-900 mb-2">ã“ã‚“ã«ã¡ã¯ï¼HealthCoach AIã§ã™ ğŸ‘‹</p>
                            <p class="text-gray-700">
                                ã‚ãªãŸã®å¥åº·ç›®æ¨™é”æˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚<br>
                                ä½•ã‹ã”è³ªå•ã‚„ã”ç›¸è«‡ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ
                            </p>
                            <div class="mt-3 text-sm text-gray-600">
                                <p>ğŸ’¡ ä¾‹ãˆã°ï¼š</p>
                                <ul class="list-disc list-inside mt-1 space-y-1 text-xs">
                                    <li>ã€Œå¥åº·çš„ãªé£Ÿäº‹ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ãã ã•ã„ã€</li>
                                    <li>ã€Œé‹å‹•ç¿’æ…£ã‚’å§‹ã‚ãŸã„ã§ã™ã€</li>
                                    <li>ã€Œç¡çœ ã®è³ªã‚’æ”¹å–„ã—ãŸã„ã§ã™ã€</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">ä»Š</p>
                </div>
            </div>
        `;
        
        this.scrollToBottom();
    }
    
    clearChat() {
        if (confirm('ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚')) {
            // Clear the chat messages display
            this.chatMessages.innerHTML = '';
            
            // Reset the session to start fresh
            this.resetChatSession();
            this.sessionId = this.getOrCreateSessionId();
            
            // Update the htmx history loading URL to use the new session ID
            this.updateHistoryLoadingUrl();
            
            console.log('Chat cleared and new session started');
        }
    }
    
    async handleFormSubmit() {
        const messageText = this.messageInput.value.trim();
        if (!messageText) {
            return;
        }
        
        // Disable input during submission
        this.setInputDisabled(true);
        
        // Add user message to chat display
        this.addUserMessage(messageText);
        
        // Clear input field and maintain focus
        this.clearInputAndMaintainFocus();
        
        try {
            // Send message to streaming API with session ID
            const response = await fetch('/api/streaming/chat', {
                method: 'POST',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'text/event-stream'
                },
                body: JSON.stringify({
                    message: messageText,
                    timezone: 'Asia/Tokyo',
                    language: 'ja',
                    chat_session_id: this.sessionId  // Use explicit chat_session_id field
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            // Process Server-Sent Events
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            // Start streaming display
            this.startStreaming();
            
            while (true) {
                const { done, value } = await reader.read();
                
                if (done) {
                    break;
                }
                
                // Add to buffer
                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                
                // Process complete lines
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // Keep incomplete line in buffer
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const eventData = JSON.parse(line.slice(6));
                            this.handleStreamingEvent(eventData);
                        } catch (e) {
                            console.error('Error parsing SSE data:', e, 'Line:', line);
                        }
                    }
                }
            }
            
        } catch (error) {
            console.error('Message sending error:', error);
            this.addErrorMessage(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${error.message}`);
        } finally {
            // Re-enable input
            this.setInputDisabled(false);
            
            if (this.isStreaming) {
                this.completeStreaming();
            }
        }
    }
    
    setInputDisabled(disabled) {
        this.messageInput.disabled = disabled;
        this.sendButton.disabled = disabled;
        
        if (disabled) {
            this.messageInput.classList.add('opacity-50', 'cursor-not-allowed');
            this.sendButton.classList.add('opacity-50', 'cursor-not-allowed');
        } else {
            this.messageInput.classList.remove('opacity-50', 'cursor-not-allowed');
            this.sendButton.classList.remove('opacity-50', 'cursor-not-allowed');
            // Restore focus after enabling
            setTimeout(() => {
                this.messageInput.focus();
            }, 100);
        }
    }
    
    setInputDisabled(disabled) {
        this.messageInput.disabled = disabled;
        this.sendButton.disabled = disabled;
        
        if (disabled) {
            this.messageInput.classList.add('opacity-50', 'cursor-not-allowed');
            this.sendButton.classList.add('opacity-50', 'cursor-not-allowed');
        } else {
            this.messageInput.classList.remove('opacity-50', 'cursor-not-allowed');
            this.sendButton.classList.remove('opacity-50', 'cursor-not-allowed');
            // Restore focus after enabling
            setTimeout(() => {
                this.messageInput.focus();
            }, 100);
        }
    }
    
    destroy() {
        if (this.eventSource) {
            this.eventSource.close();
        }
    }
}

// Initialize chat interface
let chatInterface;
document.addEventListener('DOMContentLoaded', () => {
    try {
        chatInterface = new ChatInterface();
    } catch (error) {
        console.error('Error creating ChatInterface:', error);
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (chatInterface) {
        chatInterface.destroy();
    }
});

// Logout handler
document.getElementById('logout-btn').addEventListener('click', async () => {
    if (confirm('ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
        try {
            await HealthmateUI.auth.logout();
        } catch (error) {
            console.error('Logout error:', error);
            window.location.href = '/login';
        }
    }
});
</script>
</body>
</html>